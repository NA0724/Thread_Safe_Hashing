package main

import (
	"bytes"
	"fmt"
	"math/rand"
	"strings"
	"sync"
	"time"
)

type Node struct {
	key   string
	value string
	next  *Node
}

type HashMap struct {
	Data []*Node
}

func NewDict(size int) *HashMap {
	return &HashMap{Data: make([]*Node, size)}
}

func (n *Node) String() string {
	return fmt.Sprintf("<Key: %s, Value: %s>\n", n.key, n.value)
}

// Display hashtabel in key : value pair format
func (h *HashMap) String() string {
	var output bytes.Buffer
	fmt.Fprintln(&output, "{")
	for _, n := range h.Data {
		if n != nil {
			fmt.Fprintf(&output, "\t%s: %s\n", n.key, n.value)
			for node := n.next; node != nil; node = node.next {
				fmt.Fprintf(&output, "\t%s: %s\n", node.key, node.value)
			}
		}
	}

	fmt.Fprintln(&output, "}")

	return output.String()
}

// Insert songs as key and socket as value at index in hash table [array of linked list]
func (h *HashMap) Insert(threadid int, key string, value string, index uint) {

	if h.Data[index] == nil {
		// index is empty, go ahead and insert
		h.Data[index] = &Node{key: key, value: value}
		fmt.Println("Thread id: ", threadid, " put song <", key, "> at socket <", value, "> in hash table at index ", index)
	} else {
		// there is a collision, get into linked-list mode
		curr_node := h.Data[index]
		for ; curr_node.next != nil; curr_node = curr_node.next {
			if curr_node.key == key && curr_node.value == value {
				fmt.Println("Thread id: ", threadid, " put song <", key, "> at socket <", value, "> already in hash table at index ", index)
				return
			}
		}
		if curr_node.next == nil {
			if curr_node.key == key && curr_node.value == value {
				fmt.Println("Thread id: ", threadid, " put song <", key, "> at socket <", value, "> already in hash table at index ", index)
				return
			}
		}
		curr_node.next = &Node{key: key, value: value}
		fmt.Println("Thread id: ", threadid, " put song <", key, "> at socket <", value, "> in hash table at index ", index)
	}
}

// Fetches the song (key) and all the sockets(values) from the hash table
func (h *HashMap) Get(threadid int, key string, index uint) {
	var values []string
	if h.Data[index] != nil {
		// key is on this index, but might be somewhere in linked list
		curr_node := h.Data[index]
		for ; ; curr_node = curr_node.next {
			if curr_node.key == key {
				// key matched
				values = append(values, curr_node.value)
			}
			if curr_node.next == nil {
				break
			}
		}
		if len(values) > 0 {
			fmt.Println("Thread id: ", threadid, " get song <", key, "> can be downloaded from sockets ", values)
			return
		}
	}
	// key does not exists
	fmt.Println("Thread id: ", threadid, " get song <", key, "is not in the hash table")
	return
}

// Deletes the song and socket from hashtable
func (h *HashMap) Delete(threadid int, key string, value string, index uint) {
	flag := false
	var prev *Node
	// key is on this index, but might be somewhere in linked list
	head := h.Data[index]
	curr_node := head
	for curr_node != nil {
		if curr_node.key == key && curr_node.value == value {
			if prev == nil {
				head = curr_node.next
			} else {
				prev.next = curr_node.next
			}
			flag = true
		} else {
			prev = curr_node
		}
		curr_node = curr_node.next
	}
	if flag {
		fmt.Println("Thread id: ", threadid, " delete song <", key, "> at socket <", value, "> from hash table")
	} else {
		fmt.Println("Thread id: ", threadid, " delete song <", key, "> is not in hash table")
	}

}

// The operations will be decided randomly for the random mode (the 3rd input parameter) with average of
// 70% for get, 20% for put, and 10% for delete using random number generated by calling random() in
// standard math library.
func runRandomOperations(wg *sync.WaitGroup, _ *sync.Mutex, threadid, operations int, entries []string) {
	defer wg.Done()
	var count = 1
	noOfEntries := len(entries)
	tablesize := rehash(float64(noOfEntries))
	hashtable := NewDict(tablesize)
	for j := 0; j < operations; j++ {
		if count == operations+1 {
			break
		} else {
			count++
			if j == noOfEntries {
				j = 0
			}
			//choosing operation
			val := rand.Float32()

			//fetch song and socket from entries
			s := entries[j]
			str := strings.Split(s, " ")
			song := fmt.Sprint(str[:len(str)-1])
			song = strings.Replace(song, ",", "", -1)
			socket := str[len(str)-1]

			index := generateIndex(song, tablesize)
			if val <= 0.5 {
				hashtable.Get(threadid, song, index)
			} else if val > 0.5 && val <= 0.9 {
				hashtable.Insert(threadid, song, socket, index)
			} else {
				hashtable.Delete(threadid, song, socket, index)
			}
		}
		time.Sleep(time.Millisecond * 5)
	}
	wg.Wait()
	time.Sleep(time.Millisecond * 200)

}

// Each thread (go routines) processes the list of <song name> and <socket> one by one for number of operations.
func runThreads(threads, operations int, entries []string) {
	// implement go routoines
	var wg sync.WaitGroup
	var mu sync.Mutex
	for i := 1; i <= threads; i++ {
		wg.Add(threads)
		go runRandomOperations(&wg, &mu, i, operations, entries)
		time.Sleep(time.Millisecond * 20)
		wg.Done()
	}
}

// Manual mode operations : user to enter the put/get/delete “song name” and/or “socket”
// or quit manually and verify if output is correct for sequential hashing
func doManualOperation(entries []string) {
	noOfEntries := len(entries)
	tablesize := rehash(float64(noOfEntries))
	hashtable := NewDict(tablesize)

	for _, str := range entries {
		s := strings.Split(str, " ")
		op := s[0]
		var socket string
		var song string
		if strings.HasPrefix(s[len(s)-1], "http") {
			socket = s[len(s)-1]
			song = fmt.Sprint(s[1 : len(s)-1])
		} else {
			socket = ""
			song = fmt.Sprint(s[1:])
		}
		song = strings.Replace(song, ",", "", -1)
		index := generateIndex(song, tablesize)
		if strings.Compare(op, "put") == 0 || strings.Compare(op, "Put") == 0 || strings.Compare(op, "PUT") == 0 {
			hashtable.Insert(0, song, socket, index)
		} else if strings.Compare(op, "get") == 0 || strings.Compare(op, "Get") == 0 || strings.Compare(op, "GET") == 0 {
			hashtable.Get(0, song, index)
		} else if strings.Compare(op, "delete") == 0 || strings.Compare(op, "Delete") == 0 || strings.Compare(op, "DELETE") == 0 {
			hashtable.Delete(0, song, socket, index)
		} else {
			fmt.Println("Invalid Operation")
			return
		}
	}
}
